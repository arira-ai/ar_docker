#  Docker Volumes — Hands-on


# 1. Named Volume

## 1.1 Dockerfile (Hands-on)

**Dockerfile**

```Dockerfile
FROM nginx:alpine
COPY index.html /usr/share/nginx/html/index.html
```

**index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Professional Web Page</title>

  <style>
    :root {
      --primary: #2563eb;
      --secondary: #1e293b;
      --bg: #f8fafc;
      --text: #0f172a;
      --muted: #64748b;
      --card: #ffffff;
      --radius: 10px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: "Segoe UI", Roboto, Arial, sans-serif;
    }

    body {
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
    }

    header {
      background: linear-gradient(135deg, var(--primary), #1d4ed8);
      color: white;
      padding: 3rem 1.5rem;
      text-align: center;
    }

    header h1 {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }

    header p {
      font-size: 1.1rem;
      opacity: 0.95;
    }

    .container {
      max-width: 1100px;
      margin: auto;
      padding: 2rem 1.5rem;
    }

    section {
      margin-bottom: 3rem;
    }

    h2 {
      font-size: 1.8rem;
      color: var(--secondary);
      margin-bottom: 1rem;
      border-left: 4px solid var(--primary);
      padding-left: 0.75rem;
    }

    p {
      color: var(--muted);
      margin-bottom: 1rem;
    }

    .cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 1.5rem;
      margin-top: 1.5rem;
    }

    .card {
      background: var(--card);
      padding: 1.5rem;
      border-radius: var(--radius);
      box-shadow: 0 10px 20px rgba(0,0,0,0.05);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 15px 30px rgba(0,0,0,0.08);
    }

    .card h3 {
      margin-bottom: 0.5rem;
      color: var(--primary);
    }

    .card p {
      font-size: 0.95rem;
    }

    .cta {
      background: var(--secondary);
      color: white;
      padding: 2.5rem 1.5rem;
      border-radius: var(--radius);
      text-align: center;
    }

    .cta h2 {
      color: white;
      border: none;
      padding: 0;
    }

    .cta p {
      color: #cbd5f5;
      margin: 1rem 0 1.5rem;
    }

    .cta a {
      display: inline-block;
      background: var(--primary);
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      text-decoration: none;
      font-weight: 600;
      transition: background 0.2s ease;
    }

    .cta a:hover {
      background: #1d4ed8;
    }

    footer {
      text-align: center;
      padding: 1.5rem;
      font-size: 0.9rem;
      color: var(--muted);
      border-top: 1px solid #e2e8f0;
    }

    @media (max-width: 600px) {
      header h1 {
        font-size: 2rem;
      }
    }
  </style>
</head>
<body>

  <header>
    <h1>Professional Web Interface</h1>
  </header>

  <main class="container">

    <section>
      <h2>About This Page</h2>
      <p>
        This single-page design demonstrates a clean and professional UI suitable
        for demos, training labs, Docker examples, or production placeholders.
        It uses modern CSS practices and responsive layouts.
      </p>
    </section>

    <section>
      <h2>Key Features</h2>
      <div class="cards">
        <div class="card">
          <h3>Modern Design</h3>
          <p>Uses clean colors, spacing, and typography aligned with industry UI standards.</p>
        </div>
        <div class="card">
          <h3>Responsive Layout</h3>
          <p>Adapts smoothly across desktop, tablet, and mobile screen sizes.</p>
        </div>
        <div class="card">
          <h3>Docker Friendly</h3>
          <p>Lightweight static frontend ideal for Docker image demos and CI/CD pipelines.</p>
        </div>
      </div>
    </section>

    <section class="cta">
      <h2>Ready to Use</h2>
      <p>
        Drop this file into any container, web server, or static hosting platform
        and it’s ready to go.
      </p>
      <a href="#">Get Started</a>
    </section>

  </main>

  <footer>
    © 2026 • Professional Single Page Template
  </footer>

</body>
</html>

```

### Explanation

* Image uses `nginx:alpine`
* Application content is placed in `/usr/share/nginx/html`
* This path will later be backed by a **named volume**
* Volume persists independently of container lifecycle



## 1.2 Commands to Execute

```bash
# Create named volume
docker volume create john_named_vol

# Build image
docker build -t named-vol-demo .

# Run container with named volume
docker run -d \
  --name named_vol_container \
  -v john_named_vol:/usr/share/nginx/html \
  named-vol-demo
```



## 1.3 Check and Inspect Commands

```bash
# List volumes
docker volume ls

# Inspect volume
docker volume inspect john_named_vol

# Verify data inside container
docker exec named_vol_container ls /usr/share/nginx/html
```



## 1.4 Cleanup Commands

```bash
docker stop named_vol_container
docker rm named_vol_container
docker volume rm john_named_vol
docker rmi named-vol-demo
```

---

</br>


# 2. Anonymous Volume


## 2.1 Dockerfile

**Dockerfile**

```Dockerfile
FROM alpine
VOLUME /data
CMD ["sh", "-c", "echo 'Anonymous volume data' > /data/info.txt && sleep 3600"]
```

### Explanation

* `VOLUME /data` creates an **anonymous volume**
* Docker auto-generates a random volume name
* Volume persists but is difficult to reuse

---

## 2.2 Commands to Execute

```bash
# Build image
docker build -t anon-vol-demo .

# Run container
docker run -d --name anon_vol_container anon-vol-demo
```

---

## 2.3 Check and Inspect Commands

```bash
# List volumes (note random name)
docker volume ls

# Inspect container mounts
docker inspect anon_vol_container | grep -A 10 Mounts

# Verify data
docker exec anon_vol_container cat /data/info.txt
```

---

## 2.4 Cleanup Commands

```bash
docker stop anon_vol_container
docker rm anon_vol_container

# Remove unused anonymous volumes
docker volume prune
docker rmi anon-vol-demo
```

---

<br>

Below is an **improved, production-quality version** of your **Bind Mount** section with clearer explanations, command flow, and **expected outputs** added.
No emojis used.

---

<br>

# 3. Bind Mount

A **Bind Mount** directly maps a directory from the Docker host (your laptop/server) into a container.
Any change on the host is **immediately reflected** inside the container and vice-versa.

Bind mounts tightly couple containers to the host filesystem, making them ideal for **development and debugging**, but risky for production.

---

## 3.1 Dockerfile

### Dockerfile

```Dockerfile
FROM nginx:alpine
```

### Explanation

* No application data is baked into the image
* The image remains **stateless and immutable**
* Content is injected entirely at runtime using a bind mount
* The container depends on a host directory for its data

Why this design:

* Keeps image reusable
* Allows live editing without rebuilding
* Clearly demonstrates bind mount behavior

---

## 3.2 Commands to Execute

### Step 1: Create Host Directory (Laptop Storage)

```bash
mkdir -p ~/bind_demo
echo "Hello from Bind Mount" > ~/bind_demo/index.html
```

This directory exists **physically on your laptop disk**.

---

### Step 2: Build the Image

```bash
docker build -t bind-mount-demo .
```

Expected output (truncated):

```
Sending build context to Docker daemon
Step 1/1 : FROM nginx:alpine
Successfully built <image-id>
Successfully tagged bind-mount-demo:latest
```

---

### Step 3: Run Container with Bind Mount

```bash
docker run -d \
  --name bind_mount_container \
  -v ~/bind_demo:/usr/share/nginx/html \
  bind-mount-demo
```

Expected output:

```
<container-id>
```

What happens internally:

* `~/bind_demo` (host) is mounted to `/usr/share/nginx/html` (container)
* Nginx serves files **directly from host filesystem**

---

## 3.3 Check and Inspect Commands

### Inspect Mount Details

```bash
docker inspect bind_mount_container | grep -A 10 Mounts
```

Expected output (important fields):

```
"Mounts": [
  {
    "Type": "bind",
    "Source": "/home/user/bind_demo",
    "Destination": "/usr/share/nginx/html",
    "Mode": "",
    "RW": true,
    "Propagation": "rprivate"
  }
]
```

Key observations:

* `Type: bind`
* `Source` points to host laptop path
* `RW: true` confirms read/write access

---

### Verify Data Inside Container

```bash
docker exec bind_mount_container cat /usr/share/nginx/html/index.html
```

Expected output:

```
Hello from Bind Mount
```

---

### Live Update Test (Host → Container)

Modify the file **on the host**:

```bash
echo "Updated from Host" > ~/bind_demo/index.html
```

Verify inside container:

```bash
docker exec bind_mount_container cat /usr/share/nginx/html/index.html
```

Expected output:

```
Updated from Host
```

This confirms **real-time synchronization** between host and container.

---

## 3.4 Cleanup Commands

### Stop and Remove Container

```bash
docker stop bind_mount_container
docker rm bind_mount_container
```

Expected output:

```
bind_mount_container
bind_mount_container
```

---

### Remove Image

```bash
docker rmi bind-mount-demo
```

Expected output:

```
Untagged: bind-mount-demo:latest
Deleted: sha256:<image-id>
```

---

### Remove Host Directory

```bash
rm -rf ~/bind_demo
```

This permanently deletes data from the laptop filesystem.

---

## Key Characteristics of Bind Mounts

| Aspect           | Description                      |
| ---------------- | -------------------------------- |
| Storage location | Host filesystem                  |
| Data persistence | As long as host directory exists |
| Portability      | Low                              |
| Performance      | High                             |
| Production use   | Not recommended                  |
| Development use  | Highly recommended               |

---
<br>

# 4. tmpfs Mount


## 4.1 Dockerfile

**Dockerfile**

```Dockerfile
FROM alpine
CMD ["sh", "-c", "echo 'Temporary data in memory' > /tmp/cache.txt && sleep 3600"]
```

### Explanation

* Data is stored in RAM
* Data disappears once container stops
* Used for sensitive or temporary data

---

## 4.2 Commands to Execute

```bash
# Build image
docker build -t tmpfs-demo .

# Run container with tmpfs mount
docker run -d \
  --name tmpfs_container \
  --tmpfs /tmp \
  tmpfs-demo
```

---

## 4.3 Check and Inspect Commands

```bash
# Verify data
docker exec tmpfs_container cat /tmp/cache.txt

# Inspect mount type
docker inspect tmpfs_container | grep -A 10 Mounts
```

---

## 4.4 Cleanup Commands

```bash
docker stop tmpfs_container
docker rm tmpfs_container
docker rmi tmpfs-demo
```

---

# 5. Volume Driver (Cloud / Plugin)

---

## 5.1 Dockerfile (Hands-on)

**Dockerfile**

```Dockerfile
FROM alpine
CMD ["sh", "-c", "echo 'External volume storage' > /data/cloud.txt && sleep 3600"]
```

### Explanation

* Uses external storage via Docker volume driver
* Storage exists outside Docker host
* Suitable for multi-host or cloud setups

---

## 5.2 Commands to Execute (Example: NFS-style plugin)

```bash
# Install volume plugin (example)
docker plugin install vieux/sshfs

# Create volume using driver
docker volume create \
  --driver vieux/sshfs \
  -o sshcmd=user@remote:/data \
  cloud_vol

# Build image
docker build -t cloud-vol-demo .

# Run container
docker run -d \
  --name cloud_vol_container \
  -v cloud_vol:/data \
  cloud-vol-demo
```

---

## 5.3 Check and Inspect Commands

```bash
# List volumes
docker volume ls

# Inspect volume driver
docker volume inspect cloud_vol

# Verify data
docker exec cloud_vol_container cat /data/cloud.txt
```

---

## 5.4 Cleanup Commands

```bash
docker stop cloud_vol_container
docker rm cloud_vol_container
docker volume rm cloud_vol
docker plugin disable vieux/sshfs
docker plugin rm vieux/sshfs
docker rmi cloud-vol-demo
```

---

# Final Summary

You have now **hands-on practiced all Docker volume types**:

* Named Volume (recommended for production)
* Anonymous Volume (auto-created, limited reuse)
* Bind Mount (development-focused)
* tmpfs Mount (memory-only, sensitive data)
* Volume Driver (cloud and multi-host storage)

This foundation directly prepares :

* Stateful containers
* CI/CD pipelines
* Production Docker environments
* Kubernetes persistent storage concepts
